{"version":3,"sources":["classes/Line.ts","classes/Row.ts","classes/Column.ts","classes/Subgrid.ts","classes/Cell.ts","classes/BoardError.ts","classes/Board.ts","data/puzzles.ts","components/Button/Button.tsx","components/Button/Styles.ts","styled-components/Global.ts","components/ControlBar/ControlBar.tsx","components/ControlBar/Styles.ts","utilities/utility-functions.ts","components/Cell/Cell.tsx","components/Cell/Styles.ts","components/Grid/Grid.tsx","components/Grid/Styles.ts","App.tsx","index.tsx"],"names":["Line","cells","_cells","this","cell","push","map","value","Row","Column","Subgrid","Cell","x","y","rowMap","columnMap","subgridMap","subgridArea","_x","_y","_value","_row","_column","_subgrid","_isSolved","_isMutable","_showError","get","bool","number","Set","values","has","BoardError","message","invalidCellCoordinatess","_invalidCellCoordinates","Error","Board","_board","_maxRowSize","_maxBoardSize","invalidCellCoordinates","foundInvalidCell","length","allCellValues","row","column","subgrid","i","cellArray","foundValues","j","currentCell","foundCell","getCell","console","log","JSON","stringify","convertedBoard","forEach","convertedRow","setMutable","col","isSolved","solve","canSolve","unSolve","board","boardInstance","cellBoard","Map","set","previousRowLength","currentRowLength","RangeError","Math","floor","boardLength","boardIsValid","isValid","emptyPuzzle","Button","className","children","handleClick","type","onClick","e","defaultProps","styled","StyledButtonComponent","ResetButton","ButtonComponent","ControlBar","solvePuzzle","errorMessage","resetPuzzle","ErrorMessage","as","GlobalButton","ControlBarComponent","p","cloneBoard","arr","slice","setPuzzle","setIsSolved","useState","setValue","styling","setStyling","handleFocus","target","scrollLeft","scrollWidth","setSelectionRange","useEffect","crossStyling","borderTop","includes","borderRight","borderBottom","borderLeft","background","showError","color","isMutable","MutableCell","style","onChange","targetValue","oldBoard","newBoard","onFocus","ImmutableCell","baseCellStyling","CellComponent","input","Grid","StyledGrid","MainTitle","h1","App","puzzle","setBoard","setErrorMessage","parsedBoard","parse","id","convert","find","setAllMutable","error","clonedPuzzle","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"8PAEqBA,E,WAenB,WAAYC,GAAiB,yBAdrBC,OAAiB,GAenBD,IACFE,KAAKD,OAASD,G,iDANNG,GACVD,KAAKD,OAAOG,KAAKD,K,6BARjB,OAAOD,KAAKD,OAAOI,KAAI,SAACF,GAAD,OAAUA,EAAKG,W,4BAItC,OAAOJ,KAAKD,W,KCRKM,E,4HAAYR,GCAZS,E,4HAAeT,GCAfU,E,4HAAgBV,GCEhBW,E,WA2FnB,WACEC,EACAC,EACAN,EACAO,EACAC,EACAC,EACAC,GACC,yBAlGKC,QAkGN,OAhGMC,QAgGN,OA9FMC,YA8FN,OA5FMC,UA4FN,OA1FMC,aA0FN,OAxFMC,cAwFN,OAtFMC,WAAY,EAsFlB,KApFMC,YAAa,EAoFnB,KAlFMC,YAAa,EAmFfnB,EAAQ,IACVJ,KAAKqB,WAAY,EACjBrB,KAAKsB,YAAa,GAGpBtB,KAAKe,GAAKN,EACVT,KAAKgB,GAAKN,EACVV,KAAKiB,OAASb,EAEdJ,KAAKkB,KAAO,IAAIb,EAAIO,EAAUY,IAAIf,IAClCT,KAAKmB,QAAU,IAAIb,EAAOK,EAAOa,IAAId,IACrCV,KAAKoB,SAAW,IAAIb,EAAQM,EAAWW,IAAIV,I,sDA/C3Cd,KAAKiB,OAAS,EACdjB,KAAKqB,WAAY,I,iCAGDI,GAChBzB,KAAKsB,WAAaG,I,+BAGJC,GAOd,OAN0B,IAAIC,IAAJ,sBACrB3B,KAAKkB,KAAKU,QADW,YAErB5B,KAAKmB,QAAQS,QAFQ,YAGrB5B,KAAKoB,SAASQ,UAGIC,IAAIH,K,4BAOhBA,GACX1B,KAAKiB,OAASS,EACd1B,KAAKqB,WAAY,I,gCApEjB,OAAOrB,KAAKuB,Y,aAGAE,GACZzB,KAAKuB,WAAaE,I,+BAIlB,OAAOzB,KAAKqB,Y,gCAIZ,OAAOrB,KAAKsB,a,0BAIZ,OAAOtB,KAAKkB,O,6BAIZ,OAAOlB,KAAKmB,U,8BAIZ,OAAOnB,KAAKoB,W,4BAIZ,OAAOpB,KAAKiB,Q,aAGJb,GACRJ,KAAKiB,OAASb,I,wBAId,OAAOJ,KAAKe,K,wBAIZ,OAAOf,KAAKgB,O,aChEKc,E,kDAOnB,WAAYC,EAAiBC,GAAmD,IAAD,8BAC7E,cAAMD,IAPAE,6BAMuE,EAE7E,EAAKA,wBAA0BD,EAF8C,E,mEAH7E,OAAOhC,KAAKiC,4B,eAJwBC,QCGnBC,E,WA0OnB,aACE,OADoB,yBAzOdC,YAyOa,OAvObrC,OAAiB,GAuOJ,KArOJsC,YAAc,EAqOV,KAnOJC,cAAgBtC,KAAKqC,YAAcrC,KAAKqC,YAoOhDrC,K,oDA1NMS,EAAWC,GACxB,OAAOV,KAAKoC,OAAQ3B,GAAGC,K,gCAQvB,IAHA,IAAM6B,EAAkD,GACpDC,GAAmB,EAEd/B,EAAI,EAAGA,EAAIT,KAAKoC,OAAQK,OAAQhC,GAAK,EAC5C,IAAK,IAAIC,EAAI,EAAGA,EAAIV,KAAKoC,OAAQ3B,GAAGgC,OAAQ/B,GAAK,EAY/C,IAXA,IAAMT,EAAOD,KAAKoC,OAAQ3B,GAAGC,GAIvBgC,EAAgB,CACpBzC,EAAK0C,IAAI7C,MACTG,EAAK2C,OAAO9C,MACZG,EAAK4C,QAAQ/C,OAINgD,EAAI,EAAGA,EAAIJ,EAAcD,OAAQK,GAAK,EAO7C,IANA,IAAMC,EAAYL,EAAcI,GAG1BE,EAAqC,GAGlCC,EAAI,EAAGA,EAAIF,EAAUN,OAAQQ,GAAK,EAAG,CAC5C,IAAMC,EAAcH,EAAUE,GACtB7C,EAAU8C,EAAV9C,MAER,GAAc,IAAVA,GAAgB4C,EAAY5C,IAEzB,GAAc,IAAVA,EAAa,CACtB,IAAM+C,EAAYH,EAAY5C,GAE9BmC,EAAuBrC,KAAK,CAACiD,EAAU1C,EAAG0C,EAAUzC,IACpDyC,EAAU/C,MAAQ,SAEX4C,EAAY5C,GACnBoC,GAAmB,QARnBQ,EAAY5C,GAAS8C,EAe/B,OAAIV,GACKD,I,8BAQT,IAAK,IAAIO,EAAI,EAAGA,EAAI9C,KAAKoC,OAAQK,OAAQK,GAAK,EAAG,CAG/C,IAFA,IAAMH,EAAgB,GAEbM,EAAI,EAAGA,EAAIjD,KAAKoC,OAAQU,GAAGL,OAAQQ,GAAK,EAC/CN,EAAIzC,KAAKF,KAAKoD,QAAQN,EAAGG,GAAG7C,OAI9BiD,QAAQC,IAAIC,KAAKC,UAAUb,O,gCAM7B,IAAMc,EAA6B,GAOnC,OALAzD,KAAKoC,OAAQsB,SAAQ,SAACf,GACpB,IAAMgB,EAAehB,EAAIxC,KAAI,SAACF,GAAD,OAAUA,EAAKG,SAC5CqD,EAAevD,KAAKyD,MAGfF,I,sCAIPzD,KAAKF,MAAM4D,SAAQ,SAACzD,GAClBA,EAAK2D,YAAW,Q,wCAKlB5D,KAAKF,MAAM4D,SAAQ,SAACzD,GAClBA,EAAK2D,YAAW,Q,8BAIiC,IAAxCnD,EAAuC,uDAA3B,EAAGC,EAAwB,uDAAZ,EAClCiC,EAAMlC,EACNoD,EAAMnD,EAGV,GAAImD,IAAQ7D,KAAKqC,aAAeM,IAAQ3C,KAAKqC,YAAc,EACzD,OAAO,EAILwB,IAAQ7D,KAAKqC,cACfM,GAAO,EACPkB,EAAM,GAGR,IAAM5D,EAAOD,KAAKoD,QAAQT,EAAKkB,GAG/B,GAAI5D,EAAK6D,SACP,OAAO9D,KAAK+D,MAAMpB,EAAKkB,EAAM,GAI/B,IAAK,IAAIf,EAAI,EAAGA,GAAK,EAAGA,GAAK,EAAG,CAE9B,GAAI7C,EAAK+D,SAASlB,KAEhB7C,EAAK8D,MAAMjB,GAEP9C,KAAK+D,MAAMpB,EAAKkB,EAAM,IACxB,OAAO,EAKX5D,EAAKgE,UAGP,OAAO,I,4BA3IP,OAAOjE,KAAKD,S,4BAIZ,OAAOC,KAAKoC,U,6BA0IM8B,GAA2B,IAAD,IACtCC,EAAgB,IAAIhC,EAGpBiC,EAAsB,GAC5BD,EAAc/B,OAASgC,EAUvB,IALA,IAAMxD,EAAY,IAAIyD,IAChB1D,EAAS,IAAI0D,IACbxD,EAAa,IAAIwD,IAGdvB,EAAI,EAAGA,EAAIoB,EAAMzB,OAAQK,GAAK,EACrClC,EAAU0D,IAAIxB,EAAG,IACjBnC,EAAO2D,IAAIxB,EAAG,IACdjC,EAAWyD,IAAIxB,EAAG,IAMpB,IAFA,IAAIyB,EAAiB,UAAGL,EAAM,UAAT,aAAG,EAAUzB,OAEzBhC,EAAI,EAAGA,EAAIyD,EAAMzB,OAAQhC,GAAK,EAAG,CAAC,IAAD,EAClC+D,EAAgB,UAAGN,EAAMzD,UAAT,aAAG,EAAUgC,OAEnC,IAAK8B,GACCC,IAAqBD,GACrBC,IAAqBL,EAAc9B,YAEvC,MAAM,IAAIH,MAAJ,qDAAwDiC,EAAc9B,YAAtE,MAGRkC,EAAoBC,EAEpBJ,EAAUlE,KAAKU,EAAUY,IAAIf,IAE7B,IAAK,IAAIC,EAAI,EAAGA,EAAIwD,EAAMzD,GAAGgC,OAAQ/B,GAAK,EAAG,CAC3C,IAAMN,GAAiB8D,EAAMzD,GAAGC,GAEhC,GAAIN,EAAQ,GAAKA,EAAQ,EACvB,MAAM,IAAIqE,WAAW,oDAGvB,IAAM3D,EAAc,EAAI4D,KAAKC,MAAMjE,EAAI,GAAKgE,KAAKC,MAAMlE,EAAI,GAErDR,EAAO,IAAIO,EAAKC,EAAGC,EAAGN,EAAOO,EAAQC,EAAWC,EAAYC,GAElEF,EAAUY,IAAIf,GAAIP,KAAKD,GACvBU,EAAOa,IAAId,GAAIR,KAAKD,GACpBY,EAAWW,IAAIV,GAAcZ,KAAKD,GAElCkE,EAAcpE,OAAOG,KAAKD,IAQ9B,IAAM2E,EAAcV,EAAMzB,QAAN,UAAeyB,EAAM,UAArB,aAAe,EAAUzB,QAE7C,GAAImC,IAAgBT,EAAc7B,cAChC,MAAM,IAAImC,WAAJ,0EAEFN,EAAc7B,cAFZ,kCAEmDsC,GAAe,EAFlE,YAQR,IAAMC,EAAeV,EAAcW,UAEnC,IAAqB,IAAjBD,GAAiD,kBAAjBA,EAClC,MAAM,IAAI/C,EAAW,oBAAqB+C,GAG5C,OAAOV,M,KCjKEY,EAAc,CACzB,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACzB,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACzB,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACzB,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACzB,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACzB,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACzB,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACzB,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACzB,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,ICxErBC,EAA0B,SAAC,GAAD,IAAGC,EAAH,EAAGA,UAAWC,EAAd,EAAcA,SAAUC,EAAxB,EAAwBA,YAAxB,OAC9B,wBAAQF,UAAWA,EAAWG,KAAK,SAASC,QAAS,SAACC,GAAD,OAAOH,EAAYG,IAAxE,SAA6EJ,KAS/EF,EAAOO,aAAe,CACpBL,SAAU,GACVD,UAAW,IAGED,Q,qZCrBR,IAAMA,EAASQ,YAAOC,EAAPD,CAAH,KAoBJ,GACbR,SACAU,YANyBF,YAAOR,EAAPQ,CAAH,M,yJChBjB,IAAMR,EAASQ,YAAOG,EAAPH,CAAH,KCWbI,EAA8B,SAAC,GAAD,IAEhCX,EAFgC,EAEhCA,UACAY,EAHgC,EAGhCA,YACAC,EAJgC,EAIhCA,aACAhC,EALgC,EAKhCA,SACAiC,EANgC,EAMhCA,YANgC,OASlC,sBAAKd,UAAWA,EAAhB,UACE,cAACe,EAAD,UAAeF,IAEdhC,EACC,cAAC,EAAO4B,YAAR,CAAoBO,GAAIC,EAAcf,YAAaY,EAAnD,mBAEA,cAAC,EAAOf,OAAR,CAAeiB,GAAIC,EAAcf,YAAaU,EAA9C,uBAaND,EAAWL,aAAe,CACxBN,UAAW,GACXa,aAAc,IAGDF,Q,8XC5CR,IAAMA,EAAaJ,YAAOW,EAAPX,CAAH,KAaVQ,EAAeR,IAAOY,EAAV,KChBZC,EAAa,SAACnC,GAAD,OAAuBA,EAAM/D,KAAI,SAACmG,GAAD,OAAmBA,EAAIC,YCiGnE/F,EAnFe,SAAC,GAExB,IADLyE,EACI,EADJA,UAAWhF,EACP,EADOA,KAAMuG,EACb,EADaA,UAAW1C,EACxB,EADwBA,SAAU2C,EAClC,EADkCA,YAClC,EACsBC,mBAASzG,EAAKG,OADpC,mBACGA,EADH,KACUuG,EADV,OAE0BD,mBAAS,IAFnC,mBAEGE,EAFH,KAEYC,EAFZ,KAMEC,EAAc,SAClBxB,GAGA,IAAMyB,EAASzB,EAAEyB,OAEjBA,EAAOC,WAAaD,EAAOE,YAC3BF,EAAOG,kBAAkBH,EAAO3G,MAAMqC,OAAQsE,EAAO3G,MAAMqC,SAwC7D,OAdA0E,qBAAU,WACR,IAAMC,EAAe,CACnBC,UAAW,CAAC,EAAG,GAAGC,SAASrH,EAAKQ,GAAK,iBAAmB,GACxD8G,YAAa,CAAC,EAAG,GAAGD,SAASrH,EAAKS,GAAK,iBAAmB,GAC1D8G,aAAc,CAAC,EAAG,GAAGF,SAASrH,EAAKQ,GAAK,iBAAmB,GAC3DgH,WAAY,CAAC,EAAG,GAAGH,SAASrH,EAAKS,GAAK,iBAAmB,GACzDgH,WAAYzH,EAAK0H,UAAY,MAAQ,GACrCC,MAAO3H,EAAK0H,UAAY,QAAU,IAGpCd,EAAWO,GACXT,EAAS1G,EAAKG,SACb,CAACH,EAAMA,EAAK0H,YAGb,qBAAK1C,UAAWA,EAAhB,SACGhF,EAAK4H,UACJ,cAAC,EAAOC,YAAR,CACE1C,KAAK,OACLhF,MAAOA,EAAQ,EAAIA,EAAQ,GAC3B2H,MAAOnB,EACPoB,SA5Ca,SAAC1C,GAGpB,IAAM2C,GAAe3C,EAAEyB,OAAO3G,MAAMkF,EAAEyB,OAAO3G,MAAMqC,OAAS,IAEvDwF,GAAe,GAAKA,GAAe,IAAOA,KAC7CtB,GAAS,kBAAMsB,GAAe,KAE9BzB,GAAU,SAAC0B,GACT,IAAMC,EAAW9B,EAAW6B,GAG5B,OAFAC,EAASlI,EAAKQ,GAAGR,EAAKS,GAAKuH,GAAe,EAEnCE,KAGLrE,GACF2C,GAAY,KA6BVpB,QAASyB,EACTsB,QAAStB,IAGX,cAAC,EAAOuB,cAAR,CAAsBN,MAAOnB,EAA7B,SACGxG,EAAQ,GAAKA,O,4XC/ExB,IAAMkI,EAAe,gJA4BN,GACb9H,KAnBkBgF,YAAO+C,EAAP/C,CAAH,KAoBf6C,cAb2B7C,IAAOY,EAAV,IACtBkC,GAaFR,YARyBtC,IAAOgD,MAAV,IACpBF,ICdEG,EAAwB,SAAC,GAAD,IAC5BxD,EAD4B,EAC5BA,UAAWf,EADiB,EACjBA,MAAOsC,EADU,EACVA,UAAWC,EADD,EACCA,YAAa3C,EADd,EACcA,SADd,OAG5B,qBAAKmB,UAAWA,EAAhB,SACGf,GAASA,EAAMpE,MAAMK,KAAI,SAACF,GAAD,OACxB,cAAC,EAAOO,KAAR,CAEEP,KAAMA,EACNuG,UAAWA,EACX1C,SAAUA,EACV2C,YAAaA,GALf,UACUxG,EAAKQ,EADf,YACoBR,EAAKS,UAkB/B+H,EAAKlD,aAAe,CAClBrB,MAAO,MAGMuE,Q,gcCtCR,IAAMC,EAAalD,YAAOiD,EAAPjD,CAAH,K,2QCMvB,IAAMmD,EAAYnD,IAAOoD,GAAV,KA8FAC,EAjFO,WAAO,IAAD,EACEnC,mBAAS3B,GADX,mBACnB+D,EADmB,KACXtC,EADW,OAEAE,mBAAuB,MAFvB,mBAEnBxC,EAFmB,KAEZ6E,EAFY,OAGMrC,oBAAS,GAHf,mBAGnB5C,EAHmB,KAGT2C,EAHS,OAIcC,mBAAS,IAJvB,mBAInBZ,EAJmB,KAILkD,EAJK,KA8D1B,OARA7B,qBAAU,WACR,IAAKjD,EAAO,CACV,IAAM+E,EAAc9G,EAAM+G,MAAMJ,GAEhCC,EAASE,MAEV,CAAC/E,EAAO4E,IAGT,sBAAKK,GAAG,MAAR,UACE,cAACR,EAAD,4BACA,cAACD,EAAD,CACExE,MAAOA,EACPsC,UAAWA,EACX1C,SAAUA,EACV2C,YAAaA,IAEf,cAAC,EAAD,CACEZ,YA5Dc,WAClB,IACE,IAAMoD,EAAc9G,EAAM+G,MAAMJ,GAChCG,EAAYlF,QACZgF,EAASE,GACTzC,EAAUyC,EAAaG,WAIGH,EAAYnJ,MAAMuJ,MAAK,SAACpJ,GAAD,OAAyB,IAAfA,EAAKG,UAG9D4I,EAAgB,qBAChBC,EAAYK,kBAEZN,EAAgB,IAChBvC,GAAY,IAEd,MAAO8C,GACPP,EAAgBO,EAAMxH,SACtB,IAAMyH,EAAenD,EAAWyC,GAIhCS,EAAMhH,uBAAuBmB,SAAQ,YAA+B,IAAD,mBAA5BjD,EAA4B,KAAzBC,EAAyB,KACjE8I,EAAa/I,GAAGC,GAAK,KAGvB8F,EAAUgD,GAEV,IAAMP,EAAc9G,EAAM+G,MAAMM,GAChCP,EAAYK,gBAGZC,EAAMhH,uBAAuBmB,SAAQ,YAA+B,IAAD,mBAA5BjD,EAA4B,KAAzBC,EAAyB,KACjEuI,EAAY7F,QAAQ3C,EAAGC,GAAGiH,WAAY,KAGxCoB,EAASE,KAuBPnD,aAAcA,EACdC,YApEc,WAClBgD,EAAS5G,EAAM+G,MAAMnE,IACrByB,EAAUzB,GACV0B,GAAY,IAkER3C,SAAUA,QC7FlB2F,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFC,SAASC,eAAe,W","file":"static/js/main.27556702.chunk.js","sourcesContent":["import Cell from './Cell';\n\nexport default class Line {\n  private _cells: Cell[] = [];\n\n  public get values() {\n    return this._cells.map((cell) => cell.value);\n  }\n\n  public get cells() {\n    return this._cells;\n  }\n\n  public push(cell: Cell) {\n    this._cells.push(cell);\n  }\n\n  constructor(cells?: Cell[]) {\n    if (cells) {\n      this._cells = cells;\n    }\n  }\n}\n","import Line from './Line';\n\nexport default class Row extends Line {\n\n}\n","import Line from './Line';\n\nexport default class Column extends Line {\n\n}\n","import Line from './Line';\n\nexport default class Subgrid extends Line {\n\n}\n","import Row from './Row';\nimport Column from './Column';\nimport Subgrid from './Subgrid';\n\nexport default class Cell {\n  private _x: number;\n\n  private _y: number;\n\n  private _value: number;\n\n  private _row: Row;\n\n  private _column: Column;\n\n  private _subgrid: Subgrid;\n\n  private _isSolved = false;\n\n  private _isMutable = true;\n\n  private _showError = false;\n\n  get showError() {\n    return this._showError;\n  }\n\n  set showError(bool: boolean) {\n    this._showError = bool;\n  }\n\n  get isSolved() {\n    return this._isSolved;\n  }\n\n  get isMutable() {\n    return this._isMutable;\n  }\n\n  get row() {\n    return this._row;\n  }\n\n  get column() {\n    return this._column;\n  }\n\n  get subgrid() {\n    return this._subgrid;\n  }\n\n  get value() {\n    return this._value;\n  }\n\n  set value(value) {\n    this._value = value;\n  }\n\n  public get x() {\n    return this._x;\n  }\n\n  public get y() {\n    return this._y;\n  }\n\n  public unSolve() {\n    this._value = 0;\n    this._isSolved = false;\n  }\n\n  public setMutable(bool: boolean) {\n    this._isMutable = bool;\n  }\n\n  public canSolve(number: number) {\n    const impossibleNumbers = new Set<number>([\n      ...this._row.values,\n      ...this._column.values,\n      ...this._subgrid.values,\n    ]);\n\n    if (!impossibleNumbers.has(number)) {\n      return true;\n    }\n\n    return false;\n  }\n\n  public solve(number: number): void {\n    this._value = number;\n    this._isSolved = true;\n  }\n\n  constructor(\n    x: number,\n    y: number,\n    value: number,\n    rowMap: Map<number, Cell[]>,\n    columnMap: Map<number, Cell[]>,\n    subgridMap: Map<number, Cell[]>,\n    subgridArea: number,\n  ) {\n    if (value > 0) {\n      this._isSolved = true;\n      this._isMutable = false;\n    }\n\n    this._x = x;\n    this._y = y;\n    this._value = value;\n\n    this._row = new Row(columnMap.get(x)!);\n    this._column = new Column(rowMap.get(y)!);\n    this._subgrid = new Subgrid(subgridMap.get(subgridArea)!);\n  }\n}\n","export default class BoardError extends Error {\n  private _invalidCellCoordinates: Array<[number, number]>;\n\n  get invalidCellCoordinates() {\n    return this._invalidCellCoordinates;\n  }\n\n  constructor(message: string, invalidCellCoordinatess: Array<[number, number]>) {\n    super(message);\n    this._invalidCellCoordinates = invalidCellCoordinatess;\n  }\n}\n","import Cell from './Cell';\nimport BoardError from './BoardError';\n\nexport default class Board {\n  private _board?: Cell[][];\n\n  private _cells: Cell[] = [];\n\n  private readonly _maxRowSize = 9;\n\n  private readonly _maxBoardSize = this._maxRowSize * this._maxRowSize;\n\n  public get cells() {\n    return this._cells;\n  }\n\n  public get board() {\n    return this._board;\n  }\n\n  public getCell(x: number, y: number) {\n    return this._board![x][y];\n  }\n\n  // Check's each cell to see if the board is valid (no repeated numbers in row/column/subgrid)\n  public isValid(): boolean | Array<[number, number]> {\n    const invalidCellCoordinates: Array<[number, number]> = [];\n    let foundInvalidCell = false;\n\n    for (let x = 0; x < this._board!.length; x += 1) {\n      for (let y = 0; y < this._board![x].length; y += 1) {\n        const cell = this._board![x][y];\n\n        // Put each cell's row/column/subgrid into it's own array, used so we can loop\n        // over them cleanly\n        const allCellValues = [\n          cell.row.cells,\n          cell.column.cells,\n          cell.subgrid.cells,\n        ];\n\n        // Loop over each row/column/subgrid for given cell\n        for (let i = 0; i < allCellValues.length; i += 1) {\n          const cellArray = allCellValues[i];\n\n          // foundValues object is keeping track of repeats in O(1) time\n          const foundValues: {[key: number]: Cell} = {};\n\n          // Loop over each specific value in row/column/subgrid\n          for (let j = 0; j < cellArray.length; j += 1) {\n            const currentCell = cellArray[j];\n            const { value } = currentCell;\n\n            if (value !== 0 && !foundValues[value]) {\n              foundValues[value] = currentCell;\n            } else if (value !== 0) {\n              const foundCell = foundValues[value];\n\n              invalidCellCoordinates.push([foundCell.x, foundCell.y]);\n              foundCell.value = 0;\n\n              delete foundValues[value];\n              foundInvalidCell = true;\n            }\n          }\n        }\n      }\n    }\n\n    if (foundInvalidCell) {\n      return invalidCellCoordinates;\n    }\n\n    return true;\n  }\n\n  // For debugging\n  public print() {\n    for (let i = 0; i < this._board!.length; i += 1) {\n      const row: number[] = [];\n\n      for (let j = 0; j < this._board![i].length; j += 1) {\n        row.push(this.getCell(i, j).value);\n      }\n\n      // eslint-disable-next-line no-console\n      console.log(JSON.stringify(row));\n    }\n  }\n\n  // Converts board back into a standard number array, like it would be pre-parse.\n  public convert() {\n    const convertedBoard: number[][] = [];\n\n    this._board!.forEach((row) => {\n      const convertedRow = row.map((cell) => cell.value);\n      convertedBoard.push(convertedRow);\n    });\n\n    return convertedBoard;\n  }\n\n  public setAllMutable() {\n    this.cells.forEach((cell) => {\n      cell.setMutable(true);\n    });\n  }\n\n  public setAllImmutable() {\n    this.cells.forEach((cell) => {\n      cell.setMutable(false);\n    });\n  }\n\n  public solve(x: number = 0, y: number = 0): boolean {\n    let row = x;\n    let col = y;\n\n    // Stop recursion once final cell is solved\n    if (col === this._maxRowSize && row === this._maxRowSize - 1) {\n      return true;\n    }\n\n    // Move to next row once current row is completed\n    if (col === this._maxRowSize) {\n      row += 1;\n      col = 0;\n    }\n\n    const cell = this.getCell(row, col);\n\n    // If current cell is solved, recurse to next cell\n    if (cell.isSolved) {\n      return this.solve(row, col + 1);\n    }\n\n    // Loop through all possible sudoku numbers\n    for (let i = 1; i <= 9; i += 1) {\n      // If number can be placed (not in Cell's row/column/subgrid)\n      if (cell.canSolve(i)) {\n        // Solve and recurse into next cell\n        cell.solve(i);\n\n        if (this.solve(row, col + 1)) {\n          return true;\n        }\n      }\n\n      // Else unsolve to reset cell to 0\n      cell.unSolve();\n    }\n\n    return false;\n  }\n\n  public static parse(board: Number[][]): Board {\n    const boardInstance = new Board();\n\n    // cellBoard holds the cells as a 2D array, used for O(1) lookup of cells\n    const cellBoard: Cell[][] = [];\n    boardInstance._board = cellBoard;\n\n    // Row/Column/Subgrid maps are used to map X, Y coordinates to their\n    // given row/column/subgrid. They are then attached to the cell instance\n    // so the cell can easily see which row/column/subgrid it's in.\n    const columnMap = new Map<number, Cell[]>();\n    const rowMap = new Map<number, Cell[]>();\n    const subgridMap = new Map<number, Cell[]>();\n\n    // Prefill keys for row/column maps to ensure correct ordering.\n    for (let i = 0; i < board.length; i += 1) {\n      columnMap.set(i, []);\n      rowMap.set(i, []);\n      subgridMap.set(i, []);\n    }\n\n    // Keeps track of row length, needed to determine if the 2D array is square.\n    let previousRowLength = board[0]?.length;\n\n    for (let x = 0; x < board.length; x += 1) {\n      const currentRowLength = board[x]?.length;\n\n      if (!previousRowLength\n         || currentRowLength !== previousRowLength\n         || currentRowLength !== boardInstance._maxRowSize\n      ) {\n        throw new Error(`All rows must be even and have a length of ${boardInstance._maxRowSize}.`);\n      }\n\n      previousRowLength = currentRowLength;\n\n      cellBoard.push(columnMap.get(x)!);\n\n      for (let y = 0; y < board[x].length; y += 1) {\n        const value: number = +board[x][y];\n\n        if (value < 0 || value > 9) {\n          throw new RangeError('Board must only contain numbers between 0 and 9.');\n        }\n\n        const subgridArea = 3 * Math.floor(y / 3) + Math.floor(x / 3);\n\n        const cell = new Cell(x, y, value, rowMap, columnMap, subgridMap, subgridArea);\n\n        columnMap.get(x)!.push(cell);\n        rowMap.get(y)!.push(cell);\n        subgridMap.get(subgridArea)!.push(cell);\n\n        boardInstance._cells.push(cell);\n      }\n    }\n\n    // Board Length check done here because the formula only works if the\n    // 2D array is square; which isn't determined until the for loops finish.\n    // Optimally this check would be done in the beginning of the method but\n    // this way saves having to iterate over the board twice.\n    const boardLength = board.length * board[0]?.length;\n\n    if (boardLength !== boardInstance._maxBoardSize) {\n      throw new RangeError(\n        `This application only supports 3x3 Sudoku boards with \n        ${boardInstance._maxBoardSize} cells. Your board has ${boardLength || 0} cells.`,\n      );\n    }\n\n    // Make sure board is valid now that all cells are parsed, and throw an exception if it's not\n    // Needs to be done before trying to solve board or backtracking algorithm will never finish\n    const boardIsValid = boardInstance.isValid();\n\n    if (boardIsValid !== true && typeof boardIsValid === 'object') {\n      throw new BoardError('Board is invalid.', boardIsValid);\n    }\n\n    return boardInstance;\n  }\n\n  // Use static parse method to initialize an instance.\n  public constructor() {\n    return this;\n  }\n}\n","export const completedPuzzle = [\n  [5, 3, 4, 6, 7, 8, 9, 1, 2],\n  [6, 7, 2, 1, 9, 5, 3, 4, 8],\n  [1, 9, 8, 3, 4, 2, 5, 6, 7],\n  [8, 5, 9, 7, 6, 1, 4, 2, 3],\n  [4, 2, 6, 8, 5, 3, 7, 9, 1],\n  [7, 1, 3, 9, 2, 4, 8, 5, 6],\n  [9, 6, 1, 5, 3, 7, 2, 8, 4],\n  [2, 8, 7, 4, 1, 9, 6, 3, 5],\n  [3, 4, 5, 2, 8, 6, 1, 7, 9],\n];\n\nexport const hardPuzzle = [\n  [0, 0, 0, 1, 0, 0, 2, 0, 0],\n  [3, 0, 0, 0, 0, 4, 0, 1, 0],\n  [0, 0, 5, 0, 0, 0, 6, 0, 0],\n  [1, 0, 0, 0, 5, 0, 0, 7, 0],\n  [0, 8, 0, 0, 0, 0, 0, 4, 0],\n  [0, 9, 0, 0, 2, 0, 0, 0, 1],\n  [0, 0, 2, 0, 0, 0, 9, 0, 0],\n  [0, 5, 0, 7, 0, 0, 0, 0, 8],\n  [0, 0, 6, 0, 0, 3, 0, 0, 0],\n];\n\nexport const hardPuzzleSolution = [\n  [6, 7, 8, 1, 3, 5, 2, 9, 4],\n  [3, 2, 9, 6, 8, 4, 7, 1, 5],\n  [4, 1, 5, 2, 7, 9, 6, 8, 3],\n  [1, 6, 4, 9, 5, 8, 3, 7, 2],\n  [2, 8, 7, 3, 1, 6, 5, 4, 9],\n  [5, 9, 3, 4, 2, 7, 8, 6, 1],\n  [7, 3, 2, 8, 4, 1, 9, 5, 6],\n  [9, 5, 1, 7, 6, 2, 4, 3, 8],\n  [8, 4, 6, 5, 9, 3, 1, 2, 7],\n];\n\nexport const easyPuzzle = [\n  [0, 0, 0, 1, 0, 0, 0, 0, 2],\n  [0, 0, 0, 3, 0, 0, 4, 0, 0],\n  [5, 0, 0, 6, 7, 0, 0, 1, 8],\n  [0, 0, 1, 0, 0, 7, 0, 9, 0],\n  [0, 0, 2, 0, 5, 0, 3, 0, 0],\n  [0, 8, 0, 2, 0, 0, 7, 0, 0],\n  [3, 5, 0, 0, 2, 1, 0, 0, 6],\n  [0, 0, 4, 0, 0, 8, 0, 0, 0],\n  [7, 0, 0, 0, 0, 9, 0, 0, 0],\n];\n\nexport const easyPuzzleSolution = [\n  [8, 4, 7, 1, 9, 5, 6, 3, 2],\n  [1, 9, 6, 3, 8, 2, 4, 5, 7],\n  [5, 2, 3, 6, 7, 4, 9, 1, 8],\n  [6, 3, 1, 8, 4, 7, 2, 9, 5],\n  [4, 7, 2, 9, 5, 6, 3, 8, 1],\n  [9, 8, 5, 2, 1, 3, 7, 6, 4],\n  [3, 5, 9, 7, 2, 1, 8, 4, 6],\n  [2, 6, 4, 5, 3, 8, 1, 7, 9],\n  [7, 1, 8, 4, 6, 9, 5, 2, 3],\n];\n\nexport const simplePuzzle = [\n  [5, 3, 4, 6, 7, 8, 9, 1, 2],\n  [6, 7, 2, 1, 9, 5, 3, 4, 8],\n  [1, 9, 8, 3, 4, 2, 5, 6, 7],\n  [8, 5, 9, 7, 6, 1, 4, 2, 3],\n  [4, 2, 6, 8, 0, 3, 7, 9, 1],\n  [7, 1, 3, 9, 2, 4, 8, 5, 6],\n  [9, 6, 1, 5, 3, 7, 2, 8, 4],\n  [2, 8, 7, 4, 1, 9, 6, 3, 5],\n  [3, 4, 5, 2, 8, 6, 1, 7, 9],\n];\n\nexport const emptyPuzzle = [\n  [0, 0, 0, 0, 0, 0, 0, 0, 0],\n  [0, 0, 0, 0, 0, 0, 0, 0, 0],\n  [0, 0, 0, 0, 0, 0, 0, 0, 0],\n  [0, 0, 0, 0, 0, 0, 0, 0, 0],\n  [0, 0, 0, 0, 0, 0, 0, 0, 0],\n  [0, 0, 0, 0, 0, 0, 0, 0, 0],\n  [0, 0, 0, 0, 0, 0, 0, 0, 0],\n  [0, 0, 0, 0, 0, 0, 0, 0, 0],\n  [0, 0, 0, 0, 0, 0, 0, 0, 0],\n];\n","import React from 'react';\nimport PropTypes from 'prop-types';\n\ninterface Props {\n  className?: string,\n  children?: React.ReactNode,\n  handleClick: (event: React.MouseEvent) => void\n}\n\nconst Button: React.FC<Props> = ({ className, children, handleClick }) => (\n  <button className={className} type=\"button\" onClick={(e) => handleClick(e)}>{children}</button>\n);\n\nButton.propTypes = {\n  className: PropTypes.string,\n  children: PropTypes.node,\n  handleClick: PropTypes.func.isRequired,\n};\n\nButton.defaultProps = {\n  children: '',\n  className: '',\n};\n\nexport default Button;\n","import styled from 'styled-components';\nimport StyledButtonComponent from './Button';\n\nexport const Button = styled(StyledButtonComponent)`\n  color: white;\n  background: #683aea;\n  margin-left: auto;\n  transition: all 0.3s ease;\n  border: 1px solid transparent;\n\n  @media screen and (min-width: 500px) {\n    font-size: 1.25rem;\n  }\n\n  &:hover {\n    opacity: .8;\n  }\n`;\n\nexport const ResetButton = styled(Button)`\n  background: #a911ff;\n`;\n\nexport default {\n  Button,\n  ResetButton,\n};\n","import styled from 'styled-components';\nimport ButtonComponent from '../components/Button/Button';\n\nexport const Button = styled(ButtonComponent)`\n  padding: .5em 1em;\n  border-radius: 3px;\n  border: none;\n  cursor: pointer;\n`;\n\nexport default {\n  Button,\n};\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport Styled from '../Button/Styles';\nimport { ErrorMessage } from './Styles';\nimport { Button as GlobalButton } from '../../styled-components/Global';\n\ninterface Props {\n  className?: string,\n  solvePuzzle: () => void,\n  resetPuzzle: () => void,\n  errorMessage?: string,\n  isSolved: boolean,\n}\n\nconst ControlBar: React.FC<Props> = (\n  {\n    className,\n    solvePuzzle,\n    errorMessage,\n    isSolved,\n    resetPuzzle,\n  },\n) => (\n  <div className={className}>\n    <ErrorMessage>{errorMessage}</ErrorMessage>\n\n    {isSolved ? (\n      <Styled.ResetButton as={GlobalButton} handleClick={resetPuzzle}>Reset</Styled.ResetButton>\n    ) : (\n      <Styled.Button as={GlobalButton} handleClick={solvePuzzle}>Solve</Styled.Button>\n    )}\n  </div>\n);\n\nControlBar.propTypes = {\n  className: PropTypes.string,\n  solvePuzzle: PropTypes.func.isRequired,\n  resetPuzzle: PropTypes.func.isRequired,\n  errorMessage: PropTypes.string,\n  isSolved: PropTypes.bool.isRequired,\n};\n\nControlBar.defaultProps = {\n  className: '',\n  errorMessage: '',\n};\n\nexport default ControlBar;\n","import styled from 'styled-components';\nimport ControlBarComponent from './ControlBar';\n\nexport const ControlBar = styled(ControlBarComponent)`\n  max-width: 70vw;\n  max-height: 70vw;\n  width: 300px;\n  margin: 1em 0 1em 0;\n  display: flex;\n  justify-content: space-between;\n\n  @media screen and (min-width: 500px) {\n    width: 600px;\n  }\n`;\n\nexport const ErrorMessage = styled.p`\n  color: red;\n  font-size: 1.5rem;\n`;\n\nexport default {\n  ControlBar,\n};\n","export const cloneBoard = (board: number[][]) => board.map((arr: number[]) => arr.slice());\n\nexport default {\n  cloneBoard,\n};\n","import React, { useState, useEffect } from 'react';\nimport PropTypes from 'prop-types';\nimport CellClass from '../../classes/Cell';\nimport Styled from './Styles';\nimport { cloneBoard } from '../../utilities/utility-functions';\n\ninterface Props {\n  cell: CellClass,\n  className?: string,\n  setPuzzle: React.Dispatch<React.SetStateAction<number[][]>>,\n  isSolved: boolean,\n  setIsSolved: React.Dispatch<React.SetStateAction<boolean>>,\n}\n\nconst Cell: React.FC<Props> = ({\n  className, cell, setPuzzle, isSolved, setIsSolved,\n}) => {\n  const [value, setValue] = useState(cell.value);\n  const [styling, setStyling] = useState({});\n\n  // Sets cursor to end of input field, needed to correctly\n  // overwrite prior value\n  const handleFocus = (\n    e: React.FocusEvent<HTMLInputElement> |\n    React.MouseEvent<HTMLInputElement, MouseEvent>,\n  ) => {\n    const target = e.target as HTMLInputElement;\n\n    target.scrollLeft = target.scrollWidth;\n    target.setSelectionRange(target.value.length, target.value.length);\n  };\n\n  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    // Grabs the last character in input string before converting to number. This allows the value\n    // to be changed even when another value is in place\n    const targetValue = +e.target.value[e.target.value.length - 1];\n\n    if ((targetValue >= 0 && targetValue <= 9) || !targetValue) {\n      setValue(() => targetValue || 0);\n\n      setPuzzle((oldBoard) => {\n        const newBoard = cloneBoard(oldBoard);\n        newBoard[cell.x][cell.y] = targetValue || 0;\n\n        return newBoard;\n      });\n\n      if (isSolved) {\n        setIsSolved(false);\n      }\n    }\n  };\n\n  // Set cross borders to mark subgrids on board & update cell values. Set error background\n  // if cell is invalid.\n  useEffect(() => {\n    const crossStyling = {\n      borderTop: [3, 6].includes(cell.x) ? '1px solid #000' : '',\n      borderRight: [2, 5].includes(cell.y) ? '1px solid #000' : '',\n      borderBottom: [2, 5].includes(cell.x) ? '1px solid #000' : '',\n      borderLeft: [3, 6].includes(cell.y) ? '1px solid #000' : '',\n      background: cell.showError ? 'red' : '',\n      color: cell.showError ? 'white' : '',\n    };\n\n    setStyling(crossStyling);\n    setValue(cell.value);\n  }, [cell, cell.showError]);\n\n  return (\n    <div className={className}>\n      {cell.isMutable ? (\n        <Styled.MutableCell\n          type=\"text\"\n          value={value > 0 ? value : ''}\n          style={styling}\n          onChange={handleChange}\n          onClick={handleFocus}\n          onFocus={handleFocus}\n        />\n      ) : (\n        <Styled.ImmutableCell style={styling}>\n          {value > 0 && value}\n        </Styled.ImmutableCell>\n      )}\n    </div>\n  );\n};\n\nCell.propTypes = {\n  cell: PropTypes.instanceOf(CellClass).isRequired,\n  className: PropTypes.string.isRequired,\n  setPuzzle: PropTypes.func.isRequired,\n  isSolved: PropTypes.bool.isRequired,\n  setIsSolved: PropTypes.func.isRequired,\n};\n\nexport default Cell;\n","import styled from 'styled-components';\nimport CellComponent from './Cell';\n\nconst baseCellStyling = `\n  display: grid;\n  align-items: center;\n  justify-content: center;\n  width: 100%;\n  height: 100%;\n  font-size: 1.5rem;\n  border: 0;\n`;\n\nexport const Cell = styled(CellComponent)`\n  width: 100%;\n  height: 100%;\n  border: 1px solid black;\n  box-sizing: content-box;\n`;\n\nexport const ImmutableCell = styled.p`\n  ${baseCellStyling}\n  background: #683aea;\n  color: white;\n`;\n\nexport const MutableCell = styled.input`\n  ${baseCellStyling}\n  text-align: center;\n`;\n\nexport default {\n  Cell,\n  ImmutableCell,\n  MutableCell,\n};\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport Board from '../../classes/Board';\nimport Styled from '../Cell/Styles';\n\ninterface Props {\n  className?: string,\n  board?: Board | null,\n  setPuzzle: React.Dispatch<React.SetStateAction<number[][]>>,\n  isSolved: boolean,\n  setIsSolved: React.Dispatch<React.SetStateAction<boolean>>,\n}\n\nconst Grid: React.FC<Props> = ({\n  className, board, setPuzzle, setIsSolved, isSolved,\n}) => (\n  <div className={className}>\n    {board && board.cells.map((cell) => (\n      <Styled.Cell\n        key={`${cell.x},${cell.y}`}\n        cell={cell}\n        setPuzzle={setPuzzle}\n        isSolved={isSolved}\n        setIsSolved={setIsSolved}\n      />\n    ))}\n  </div>\n);\n\nGrid.propTypes = {\n  className: PropTypes.string.isRequired,\n  board: PropTypes.instanceOf(Board),\n  setPuzzle: PropTypes.func.isRequired,\n  isSolved: PropTypes.bool.isRequired,\n  setIsSolved: PropTypes.func.isRequired,\n};\n\nGrid.defaultProps = {\n  board: null,\n};\n\nexport default Grid;\n","import styled from 'styled-components';\nimport Grid from './Grid';\n\nexport const StyledGrid = styled(Grid)`\n  max-width: 70vw;\n  max-height: 70vw;\n  width: 300px;\n  height: 300px;\n  background: white;\n  display: grid;\n  grid-template-columns: repeat(9, minmax(0, 1fr));\n  grid-template-rows: repeat(9, minmax(0, 1fr));\n  align-items: center;\n  justify-content: center;\n  grid-gap: 1px;\n\n  @media screen and (min-width: 500px) {\n    width: 600px;\n    height: 600px;\n  }\n`;\n\nexport default {\n  StyledGrid,\n};\n","import React, { useState, useEffect } from 'react';\nimport './App.css';\nimport styled from 'styled-components';\nimport Board from './classes/Board';\nimport { emptyPuzzle } from './data/puzzles';\nimport { ControlBar as StyledControlBar } from './components/ControlBar/Styles';\nimport { StyledGrid } from './components/Grid/Styles';\nimport { cloneBoard } from './utilities/utility-functions';\n\nconst MainTitle = styled.h1`\n  color: #683aea;\n  font-size: 2rem;\n  text-align: center;\n  display: block;\n  margin-bottom: .5em;\n  margin-top: 1em;\n\n  @media screen and (min-width: 500px) {\n    font-size: 3rem;\n  }\n`;\n\nconst App: React.FC = () => {\n  const [puzzle, setPuzzle] = useState(emptyPuzzle);\n  const [board, setBoard] = useState<Board | null>(null);\n  const [isSolved, setIsSolved] = useState(false);\n  const [errorMessage, setErrorMessage] = useState('');\n\n  const resetPuzzle = () => {\n    setBoard(Board.parse(emptyPuzzle));\n    setPuzzle(emptyPuzzle);\n    setIsSolved(false);\n  };\n\n  const solvePuzzle = () => {\n    try {\n      const parsedBoard = Board.parse(puzzle);\n      parsedBoard.solve();\n      setBoard(parsedBoard);\n      setPuzzle(parsedBoard!.convert());\n\n      // In cases where board is parsed completely and left with unsolveable cells\n      // notify user & allow cells to be editable again\n      const isImpossibleBoard = parsedBoard.cells.find((cell) => cell.value === 0);\n\n      if (isImpossibleBoard) {\n        setErrorMessage('Impossible board.');\n        parsedBoard.setAllMutable();\n      } else {\n        setErrorMessage('');\n        setIsSolved(true);\n      }\n    } catch (error) {\n      setErrorMessage(error.message);\n      const clonedPuzzle = cloneBoard(puzzle);\n\n      // Set invalid cells to 0 in puzzle, used to prevent error\n      // when board is parsed\n      error.invalidCellCoordinates.forEach(([x, y]: [number, number]) => {\n        clonedPuzzle[x][y] = 0;\n      });\n\n      setPuzzle(clonedPuzzle);\n\n      const parsedBoard = Board.parse(clonedPuzzle);\n      parsedBoard.setAllMutable();\n\n      // Show error on same errored cells on the UI after parse is complete\n      error.invalidCellCoordinates.forEach(([x, y]: [number, number]) => {\n        parsedBoard.getCell(x, y).showError = true;\n      });\n\n      setBoard(parsedBoard);\n    }\n  };\n\n  useEffect(() => {\n    if (!board) {\n      const parsedBoard = Board.parse(puzzle);\n\n      setBoard(parsedBoard);\n    }\n  }, [board, puzzle]);\n\n  return (\n    <div id=\"app\">\n      <MainTitle>Sudoku Solver</MainTitle>\n      <StyledGrid\n        board={board}\n        setPuzzle={setPuzzle}\n        isSolved={isSolved}\n        setIsSolved={setIsSolved}\n      />\n      <StyledControlBar\n        solvePuzzle={solvePuzzle}\n        errorMessage={errorMessage}\n        resetPuzzle={resetPuzzle}\n        isSolved={isSolved}\n      />\n    </div>\n  );\n};\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root'),\n);\n"],"sourceRoot":""}